# Assignment 8: Digits

### Deadline

11 November 2022 (Friday), 23:59 PM

Note: Late penalty is waived until 15 November (Tuesday), 23:59.  No approval or justification is needed to waive the late penalty.  Late penalty applies after 16 November 00:01.

### Learning Objectives

- Able to use 2D array and struct to store data 
- Able to implement partial sorting algorithms

### Grading

This assignment contributes to **4.5%** of your final grade.  The total marks for this assignment are 45 marks.

We may deduct up to 2 marks for style violation.  Ensure that your code is neat and readable, adhering to the CS1010 coding convention.

Marks are no longer allocated to documentation. We may deduct up to 4 marks for missing documentation.  Your code should follow the good practices of breaking down your solution into small functions. Document each function (except `main`) following the Doxygen documentation format, as outlined [here](../guides/documentation.md).

10 marks are allocated for efficiency.  You need to solve the problem within the given running time to get the efficiency marks.  _We may deduct marks if your code is inefficient (e.g., perform redundant or duplicate work), even if its running time is within the given bound_.  Note that if your approach to solving the problem is incorrect, no efficiency marks will be given.

The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions.  Note that _even if your solution produces the correct output every time, it may not get full marks if the approach is wrong._

## Digits (45 Marks)

We started CS1010 with an assignment question on digits, so it is fitting that we end with one.

In this assignment, your goal is to write a program that can recognize handwritten digits. This is a classic problem in pattern recognition and machine learning. The state-of-the-art techniques can now achieve a recognition rate of over 99%. We, however, will implement a simple algorithm called the $k$-nearest neighbor algorithm, which has a lower accuracy but is simpler.

### Supervised Machine Learning

The $k$-nearest neighbor algorithm belongs to a category of algorithms called _supervised_ machine learning_ algorithms.  These algorithms teach or train the machine to learn to do something, by showing the machine many samples.  These are called _training samples_.  After showing the machine a bunch of these training samples, we can then _test_ the machine how well it has learned, by showing the machine some _testing samples_.

In our case, we want to train the machine to recognize handwritten digits.  During the training phase, we will present a set of handwritten digits in the form of images (as 2D arrays) to the machine, together with a label indicating which digits it is (i.e., "this picture shows the digit 1, this picture shows the digit 4, etc.").  During the testing phase, we will then present a set of handwritten digits to the machine, and ask, "ok, which digit do you think this is?"

We will then compare the machine's answer with the label of the handwritten digit (also called the _ground truth_) to see whether the machine recognizes it correctly or not.

### Representation of a handwritten digit

A handwritten digit is an image, represented as a 28-by-28 array of characters, consisting of `.` and `#`. An example is:

```
............................
............................
............................
..........#######...........
.........########...........
........##########..........
.......####....###..........
.......###....####..........
..............####..........
.............####...........
............#####...........
............####............
...........####.............
...........###..............
..........####..............
.........####...............
.........####...............
........####................
........###.................
........###...........####..
........###################.
........###################.
.........###########........
............................
............................
............................
............................
............................
```

The image above contains the digit 2.

### Training Data

For this assignment, we will use the data provided by the MNIST Handwritten Digit Database. The original data has been post-processed into CSV file by Joseph Redmon, then post-processed again by yours truly into the format above.

The dataset from above contains 60,000 training samples. I have created two smaller subsets for you to test your code.

- The first subset contains 10 samples for each digit -- this is given in the file `train100.in`.
- The second subset contains 6 samples for digits 0 and 1 -- this is given in the file `train6.in`.

The full training set from MNIST is too big to be included on GitHub. You can read it from `~cs1010/as09/train60000.in` if you want to play with it.

### Testing Samples

We provide two sets of testing samples. The first contains three testing samples per digit. The second contains only a single digit corresponding to the example below.

The full training dataset from MNIST contains 10000 digits. It takes a long time to test every handwritten digit in this file, so you should do this only after you have made sure that your code is fast and correct. Again, the file is too big to be posted on GitHub. You can read it directly from `~cs1010/as09/test10000.in`.

### The Algorithm

We will use the $k$-nearest neighbor algorithm for this assignment.  The idea of this algorithm is that, given a testing sample, the machine will compare it to all the training samples, and find out which digit this testing sample is most similar to.

Let's define the distance between the two handwritten digits $d(x_1,x_2)$ as the number of pixels that are different between them, i.e., how many pixels are `#` in one image but is `.` in the other image.

Given a test sample, $q$, we find the distance between $q$ and all the available training samples and find the $k$ training samples with the smallest distance (i.e., $k$-nearest neighbors).  $k$ is usually small -- we use $k$ = 5 in this assignment.

The intuition is that $q$ must be "close" to the training data that has the same labels (i.e., the same digits). So we look at these $k$-nearest neighbors and find the most common digit $d$ among them. We then recognize $q$ as containing the digit $d$. 

There are two tie-breaking scenarios that we need to consider.  First, if there are more than $k$ nearest neighbors.  In this case, we pick the nearest $k$ by favoring the smaller digit.  For example, if we have the following training samples:

| digit | distance |
|------|------|
|  3   | 120  | 
|  2   | 125  | 
|  3   | 131  | 
|  7   | 140  | 
|  1   | 140  | 
|  2   | 140  | 

We favor 1 and 2 and eliminate 7 from the top-$k$ since they are smaller than 7.

Second, multiple digits may tie as the most common digit.  In this case, we choose the one that has the smaller distance. 
In the example above, after eliminating 7, both 2 and 3 are tied for the most common digit as they both appear twice among the top 5.  We choose 3 since it has a smaller distance (120 vs. 125).  If the closest samples of the digits have the same distance, then we again break ties by favoring the smaller digit.  For example, if the digit 2 in the second entry in the table above also has a distance of 120, then we pick 2 since 2 is the smaller digit.

### Efficiency

Suppose we have $n$ training samples, recognizing a digit should take no more than $O(kn)$ time (or $O(n)$ since $k$ is a constant).

There is also an opportunity to stop early the calculation of the distance between two handwritten digits if the distance is too large, pruning away redundant work.

### Example

Consider the following simple example with six training samples and a test sample.

```
6
0
............................
............................
............................
............................
...............#####........
...............#####........
.............########.......
............##########......
...........###########......
..........########.###......
..........####.##...###.....
.........#####......###.....
........####........###.....
.......####.........###.....
.......###..........###.....
......####..........###.....
......###..........###......
......###.........####......
......###........###........
......###......####.........
......####..#######.........
......###########...........
.......########.............
........#####...............
............................
............................
............................
............................
0
............................
............................
............................
............................
.................####.......
................######......
...............#######......
.............#########......
...........###########......
..........############......
.........#############......
........#####.####.###......
.......#####..###...##......
.......####.........##......
.......##...........##......
......###...........##......
.....####..........###......
.....####..........###......
.....####.........###.......
.....####.......####........
.....##############.........
......############..........
........########............
.........######.............
............................
............................
............................
............................
0
............................
............................
............................
............................
............................
..............######........
..............########......
.............#########......
.............#########......
............##########......
..........######..####......
..........#####...####......
..........#####...####......
..........#####..#####......
..........####...#####......
.........####....####.......
........#####...#####.......
........#####...####........
........#####..#####........
........####..#####.........
........##########..........
........#########...........
........#########...........
.........######.............
..........#####.............
............................
............................
............................
1
............................
............................
............................
............................
............................
..................####......
.................#####......
.................#####......
................####........
...............#####........
...............####.........
...............####.........
..............####..........
.............####...........
............####............
............####............
...........####.............
...........####.............
..........####..............
..........####..............
.........####...............
.........####...............
........####................
........####................
.........###................
............................
............................
............................
1
............................
............................
............................
............................
............###.............
............####............
............####............
............####............
............####............
............####............
............#####...........
.............####...........
.............####...........
.............####...........
.............####...........
.............####...........
.............####...........
.............####...........
.............#####..........
.............#####..........
..............####..........
..............####..........
..............####..........
...............###..........
............................
............................
............................
............................
1
............................
............................
............................
............................
............................
.............##.............
.............##.............
.............##.............
.............##.............
.............###............
.............###............
.............###............
.............###............
.............###............
.............###............
.............###............
.............###............
.............###............
.............###............
..............###...........
..............##............
..............##............
..............###...........
..............##............
..............##............
............................
............................
............................
```

The test sample is

```
1
0
............................
............................
............................
............................
............................
..............#####.........
.............#######........
...........##########.......
..........####.##.####......
.........####......####.....
.........###........###.....
........####.........##.....
........###..........##.....
.......###...........##.....
.......###...........##.....
.......###...........##.....
......####...........##.....
......####..........###.....
.......###..........###.....
.......###.........###......
........###.......###.......
........####....#####.......
.........##########.........
..........#########.........
............#####...........
............................
............................
............................
```

The distances between the test sample and each of the training samples are 101, 120, 162, 174, 173, and 162. The $k$ nearest neighbors belong to digits 0, 0, 0, 1, and 1. The most common digit among these neighbors is 0, so we conclude (correctly) that the test sample is digit 0.

### Using struct

One of the objectives of this assignment is to see if you know how to use `struct`.

For this assignment, you must define and use two `struct`:

- a `struct digit` that encapsulates the 2D array that represents the handwritten digit and its label,

- a `struct neighbor` that encapsulates a neighboring digit and the distance to it.

### Input/Output

Write a program `digits` that reads, from the standard input, the following:

- A positive integer $n$, corresponding to the number of training samples, then repeatedly read $n$ handwritten digits, containing:

  - a label corresponding to the digit in the next image (a number between 0 - 9)

  - 28 lines of text, consisting of '.' and '#' only, representing a handwritten digit

- followed by another positive integer $m$, corresponding to the number testing samples, then repeatedly read $m$ handwritten digits, containing:

  - a label corresponding to the digit in the next image (a number between 0 - 9)
  - 28 lines of text, consisting of '.' and '#' only, representing a handwritten digit

Then prints, to the standard output, the following:

For each testing sample,

- print the digit it is labeled as, followed by a space, followed by the digit it is recognized as.

Finally, print a double value that corresponds to the accuracy, i.e, the percentage of training testing samples correctly recognized.

We separated the training samples and testing samples into two files, so the usual way of redirecting a file into your program does not work anymore (since you need two files).

The way to run your program is to do the following:

```
cat <training samples> <testing samples> | ./digits
```

We use `cat`, which concatenates two files into one to pass both the training samples and testing samples into the program using the pipe `|`.

The name convention for the output files is different for this assignment. The name is formatted as `X-Y.out` where `X` refers to the training samples `trainX.in` and `Y` refers to the testing samples `testY.in`.

### Testing

In addition to the MNIST dataset, a small set of test data has been provided to help you test your code.  These are given in the files `digits.X.in` and `digits.X.out` in the `inputs` and `outputs` directory.  They are hand-crafted inputs that do not contain any digit-like data.

If you wish to test using only these hand-crated test cases, run
```
./test.sh digits
```

You can also run
```
./test.sh digits <X> <Y>
```

to test with the training samples `trainX.in` and testing samples `testY.in`.

Running 
```
make
```

will cycle through testing with these test cases as usual, followed by a combination of training/testing data.


### Sample Runs

```
ooiwt@pe121:~/cs1010/as09$ cat inputs/train6.in inputs/test1.in | ./digits
0 0
100.0000
ooiwt@pe121:~/cs1010/as09$ cat inputs/train100.in inputs/test30.in | ./digits
0 0
0 0
0 6
1 1
1 1
1 1
2 2
2 5
2 2
3 3
3 3
3 3
4 9
4 4
4 9
5 5
5 3
5 3
6 2
6 6
6 6
7 7
7 7
7 7
8 8
8 1
8 8
9 9
9 9
9 9
73.3333
```

When you use the file `~cs1010/as09/train60000.in` as the training samples, you should get 100% accuracy with `test30.in` and 96.56% accuracy with `~cs1010/as09/test10000.in`

To speed up your code, you can remove the following lines from `compile_flags.txt`

```
-g
-fsanitize=bounds
-fsanitize=address
```

